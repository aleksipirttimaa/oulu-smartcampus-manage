//
// Frontend -helpers
//
// These are only intended to be used with the current version
// of the Frontend. There isn't a need to keep them backwards
// compatible or documented in Swagger.
//

const express = require('express');
const Influx = require('influx');
const router = express.Router();

const influxDbConfig = require('../config/influx-db');
const Device = require('../models/device');
const Roles = require('../roles');
const User = require('../models/user');

//
// Map
//
// params: floor, state
//

router.get('/map', (req, res, next) => {
    let query = {};
    if (req.params.floorLevel) {
        query.floorLevel = new Array(req.params.floorLevel);
    }
    if (req.params.status) {
        query.status = new Array(req.params.status);
    }
    Device.find(query).where({location: {$exists: true, $ne: null}}).exec((err, devices) => {
        // TODO: fix code duplication
        if (err) {
            console.warn('Front-End Map:', err);
            return res.json([]);
        }
        // Device model doesn't contain the full name of the user
        // even though we want it on the map

        // lets add 'added by user full name' to every device asynchronously
        const devicePromises = devices.map(device => {
            return new Promise((resolve, _reject) => {
                User.getUserById(device.addedByUser, (err, user) => {
                    const addedByUserFullName = (!err && user) ? user.name : 'Unknown user';
                    resolve({addedByUserFullName, ...device.toObject()});
                });
            });
        });

        // wait for all promises to resolve
        Promise.all(devicePromises).then(resolvedDevices => {
            res.json(resolvedDevices);
        });
    });
});

//
// list unmapped devices
//

router.get('/list-unmapped', Roles.authorize("device-manager"), (req, res, next) => {
    Device.find({location: null}, (err, devices) => {
        // TODO: fix code duplication
        if (err) {
            console.warn('Front-End List unmapped:', err);
            return res.json([]);
        }
        // Device model doesn't contain the full name of the user
        // even though we want it on the map

        // lets add 'added by user full name' to every device asynchronously
        const devicePromises = devices.map(device => {
            return new Promise((resolve, _reject) => {
                User.getUserById(device.addedByUser, (err, user) => {
                    const addedByUserFullName = (!err && user) ? user.name : 'Unknown user';
                    resolve({addedByUserFullName, ...device.toObject()});
                });
            });
        });

        // wait for all promises to resolve
        Promise.all(devicePromises).then(resolvedDevices => {
            res.json(resolvedDevices);
        });
    });
});

//
// Device Card
//

/* full example in oulu-smartcampus-sensorstatus */

function influx_sensor(eui) {
    /* utility to help convert */
    /* input AABBCCDDEEFF */
    /* return aa-bb-ff-cc-dd-ee-ff */
    if (!eui || typeof eui !== 'string') {
        return null;
    }
    return eui.toLowerCase().replace(/(.{2})/g,"$1-").slice(0, -1);
}

class SensorStatus {
    constructor() {
        this.influx = null;
    }
    connect() {
        this.influx = new Influx.InfluxDB(influxDbConfig.options);
    }
    getSensor(eui, cb) {
        const sensor = influx_sensor(eui);
        /* get link information aka. values generated on the GW */
        const influx = this.influx;
        const link_query = `SELECT "rssi", "port", "chan"` +
                        `FROM "autogen"."mqtt_consumer" ` +
                        `WHERE "deveui" = '${sensor}' ` +
                        `AND "topic"='cwc/LoRaWAN_GW1/uplink' ` + /* TODO: support multiple GW's */
                        `AND time > now() - 2d ` + /* excluding old values speeds up the query */
                        `ORDER BY DESC LIMIT 1`
        influx.query(link_query).then((link_result) => {
            if(link_result[0]) {
                let ret = {
                    lastSeen: link_result[0].time,
                    rssi: link_result[0].rssi,
                    port: link_result[0].port,
                    channel: link_result[0].chan,
                };
                /* get parsed values aka. values generated by elsysparser */
                const app_query = `SELECT "battery", "temperature", "humidity", "light", "motion", ` +
                                `"co2", "sound_avg", "sound_peak", "pressure", "moisture", ` +
                                `"occupancy" ` +
                                `FROM "autogen"."mqtt_consumer" ` + 
                                `WHERE "deveui" = '${sensor}' ` + 
                                `AND "topic"='cwc/elsys/parsed' ` +
                                `AND time > now() - 2d ` +
                                `ORDER BY DESC LIMIT 1`;
                influx.query(app_query).then((app_result) => {
                    if (app_result[0]) {
                        /* optionals will be "null" */
                        ret.battery = app_result[0].battery;
                        ret.temperature = app_result[0].temperature;
                        ret.humidity = app_result[0].humidity;
                        ret.light = app_result[0].light;
                        ret.motion = app_result[0].motion;
                        ret.co2 = app_result[0].co2;
                        ret.sound_avg = app_result[0].sound_avg;
                        ret.sound_peak = app_result[0].sound_peak;
                        ret.pressure = app_result[0].pressure;
                        ret.moisture = app_result[0].moisture;
                        ret.occupancy = app_result[0].occupancy;
                    }
                    cb(false, ret);
                }).catch((err) => {
                    cb(err);
                });
            } else {
                cb(false, null);
            }
        }).catch((err) => {
            cb(err);
        });
    }
}

// shuffle in place
//https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
//https://stackoverflow.com/users/310500/laurens-holst
function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// pick n random keys from object (never pick lastSeen)
function pick(n, obj) {
    let picked = {};
    let keys = Object.keys(obj);
    shuffle(keys);
    keys.forEach(key => {
        if (key === 'lastSeen') {
            // is lastSeen
            return;
        }
        if (!obj[key]) {
            // is null
            return;
        }
        if (Object.keys(picked).length > n - 1) {
            // at target length
            return;
        }
        picked = { ...picked, [key]: obj[key] };
    });
    return picked;
}

router.get('/device-card/:_id', (req, res, next) => {
    const _id = req.params._id;
    Device.findById(_id, (err, device) => {
        if (err || !device) {
            return res.json({ success: false, msg: `Failed getting device: ${err}`});
        }
        if (
            device.deviceType.startsWith("Elsys ")) {
            const ss = new SensorStatus();
            ss.connect();
            ss.getSensor(device.deviceId, (err, data) => {
                if (err) {
                    console.error('get sensor error', err);
                    return res.json({ success: false, msg: `Failed getting sensor card ${err}`});
                }
                if (!data) {
                    return res.json({ success: false, msg: `This sensor has not been seen lately`});
                }
                let nCards = 8;
                let card = pick(nCards, data);
                card.lastSeen = data.lastSeen;
                res.json({ success: true, card });
            });
        } else {
            // no data for this device type
            res.json({ success: true, card: {}});
        }
    });
});

//
// front page
//

router.get('/home', (req, res, next) => {
    Device.find({ status: ['online', 'installed'] }, (err, devices) => {
        if (err || ! devices) {
            return res.json({});
        }
        res.json({ nOnline: devices.length });
    });
});

//
// quick-search
//

router.post('/device-quick-search', (req, res, next) => {
    if (!req.body.query) {
        return res.json({ success: false, msg: 'Missing query', result: []});
    }

    // ugly way to prevent arbitrary regex
    let query = req.body.query.replace('[^a-zA-Z0-9 ]', '');

    if (query.length < 3) {
        return res.json({ success: false, msg: 'Query too short', result: []});
    }

    Device.find({ $or: [
            { 'deviceId': { $regex: query + '$', $options: 'i' }},
            { 'description': { $regex: query, $options: 'i' }},
            { 'status': { $regex: query, $options: 'i' }},
        ]})
        .limit(11)
        .exec((err, devices) => {
            if (err || !devices) {
                throw err;
                return res.json({ success: false, msg: 'Query error', result: []});
            }
            const result = devices.map(d => {
                return {
                    _id: d._id,
                    description: d.description,
                    deviceId: d.deviceId,
                    deviceType: d.deviceType,
                    status: d.status,
                }
            })
            return res.json({ success: true, result});
        });
});

router.get('/config', (req, res, next) => {
    return res.json({
        'device': {
            'levels': ['6', '5', '4', '3', '2', '1', '-1', '-2'],
            'types': [
                'Elsys EMS',
                'Elsys EMS Door',
                'Elsys EMS Desk',
                'Elsys EMS Lite',
                'Elsys ERS CO2',
                'Elsys ERS Eye',
                'Elsys ERS Sound',
                'Elsys ELT-2 with soil moisture',
                'Other',
            ],
            'userStatuses': ['installed', 'planned', 'maintenance'],
        },
        'map': {
            'jumpTo': {
                'Linnanmaa': [[65.0591022, 25.4665], 16],
                'Kontinkangas': [[65.00781363, 25.5235147476], 16],
                'Botanical garden': [[65.063546027, 25.4654502868], 17]
            }
        }
    });
});

module.exports = router;